import * as functions from 'firebase-functions';
import * as admin from 'firebase-admin';
import Stripe from 'stripe';
import * as sgMail from '@sendgrid/mail';

// Initialize services
admin.initializeApp();
const db = admin.firestore();

// Initialize Stripe with error handling
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY || '', {
  apiVersion: '2024-11-20.acacia',
});

// Initialize SendGrid
if (process.env.SENDGRID_API_KEY) {
  sgMail.setApiKey(process.env.SENDGRID_API_KEY);
}

// ==========================================
// Callable: Create Payment Intent
// ==========================================
export const createPaymentIntent = functions.https.onCall(
  async (data, context) => {
    if (!context.auth) {
      throw new functions.https.HttpsError('unauthenticated', 'User must be logged in');
    }

    const { bookingId } = data;
    if (!bookingId) {
      throw new functions.https.HttpsError('invalid-argument', 'Booking ID is required');
    }

    try {
      const bookingRef = db.collection('bookings').doc(bookingId);
      const bookingDoc = await bookingRef.get();

      if (!bookingDoc.exists) {
        throw new functions.https.HttpsError('not-found', 'Booking not found');
      }

      const booking = bookingDoc.data()!;

      // Verify user is guest
      if (booking.guestId !== context.auth.uid) {
        throw new functions.https.HttpsError('permission-denied', 'Unauthorized');
      }

      // Create Stripe Payment Intent
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(booking.totalPrice * 100),
        currency: booking.currency || 'usd',
        metadata: {
          bookingId,
          guestId: booking.guestId,
          hostId: booking.hostId,
          listingId: booking.listingId,
        },
        automatic_payment_methods: { enabled: true },
      });

      // Update booking with payment intent
      await bookingRef.update({
        paymentIntentId: paymentIntent.id,
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      });

      return {
        success: true,
        clientSecret: paymentIntent.client_secret,
        paymentIntentId: paymentIntent.id,
      };
    } catch (error: any) {
      functions.logger.error('Error creating payment intent:', error);
      throw new functions.https.HttpsError(
        'internal',
        error.message || 'Failed to create payment intent'
      );
    }
  }
);

// ==========================================
// Callable: Create Ephemeral Key (for Stripe Customer Sheet)
// ==========================================
export const createEphemeralKey = functions.https.onCall(
  async (data, context) => {
    if (!context.auth) {
      throw new functions.https.HttpsError('unauthenticated', 'User must be logged in');
    }

    const { customerId } = data;
    if (!customerId) {
      throw new functions.https.HttpsError('invalid-argument', 'Customer ID is required');
    }

    try {
      const key = await stripe.ephemeralKeys.create(
        { customer: customerId },
        { apiVersion: '2024-11-20.acacia' }
      );
      return { success: true, ephemeralKey: key.secret };
    } catch (error: any) {
      functions.logger.error('Error creating ephemeral key:', error);
      throw new functions.https.HttpsError(
        'internal',
        error.message || 'Failed to create ephemeral key'
      );
    }
  }
);

// ==========================================
// Webhook: Handle Stripe Payment Events
// ==========================================
export const stripeWebhook = functions.https.onRequest(
  async (req, res) => {
    const sig = req.headers['stripe-signature'] as string;
    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;

    if (!webhookSecret) {
      functions.logger.error('Webhook secret not configured');
      return res.status(500).send('Webhook secret missing');
    }

    let event: Stripe.Event;
    try {
      event = stripe.webhooks.constructEvent(req.rawBody, sig, webhookSecret);
    } catch (err: any) {
      functions.logger.error('Webhook verification failed:', err.message);
      return res.status(400).send(`Webhook Error: ${err.message}`);
    }

    try {
      switch (event.type) {
        case 'payment_intent.succeeded':
          await handlePaymentSuccess(event.data.object as Stripe.PaymentIntent);
          break;

        case 'payment_intent.payment_failed':
          await handlePaymentFailed(event.data.object as Stripe.PaymentIntent);
          break;

        case 'charge.refunded':
          await handleRefund(event.data.object as Stripe.Charge);
          break;

        default:
          functions.logger.info(`Unhandled event type: ${event.type}`);
      }

      res.json({ received: true });
    } catch (error: any) {
      functions.logger.error('Webhook handler error:', error);
      res.status(500).send('Webhook processing failed');
    }
  }
);

// ==========================================
// Helper: Handle Payment Success
// ==========================================
async function handlePaymentSuccess(paymentIntent: Stripe.PaymentIntent) {
  const bookingId = paymentIntent.metadata.bookingId;
  const hostId = paymentIntent.metadata.hostId;

  if (!bookingId || !hostId) {
    throw new Error('Missing metadata in payment intent');
  }

  const bookingRef = db.collection('bookings').doc(bookingId);
  const bookingDoc = await bookingRef.get();

  if (!bookingDoc.exists) {
    throw new Error(`Booking ${bookingId} not found`);
  }

  const booking = bookingDoc.data()!;

  // Update booking status
  await bookingRef.update({
    status: 'confirmed',
    paymentStatus: 'paid',
    stripePaymentIntentId: paymentIntent.id,
    paidAt: admin.firestore.FieldValue.serverTimestamp(),
    updatedAt: admin.firestore.FieldValue.serverTimestamp(),
  });

  // Create Stripe Connect transfer (host payout)
  await createHostTransfer(hostId, booking, paymentIntent);

  // Send notifications
  await sendBookingConfirmationEmails(bookingId, booking);
  await sendNotification(booking.guestId, 'Booking Confirmed', `Your booking is confirmed!`);
  await sendNotification(hostId, 'New Booking', `You have a new booking!`);
}

// ==========================================
// Helper: Handle Payment Failed
// ==========================================
async function handlePaymentFailed(paymentIntent: Stripe.PaymentIntent) {
  const bookingId = paymentIntent.metadata.bookingId;

  if (!bookingId) return;

  await db.collection('bookings').doc(bookingId).update({
    status: 'payment_failed',
    paymentStatus: 'failed',
    updatedAt: admin.firestore.FieldValue.serverTimestamp(),
  });

  const bookingDoc = await db.collection('bookings').doc(bookingId).get();
  const booking = bookingDoc.data();

  if (booking) {
    await sendNotification(
      booking.guestId,
      'Payment Failed',
      'Your payment failed. Please try again.'
    );
  }
}

// ==========================================
// Helper: Handle Refund
// ==========================================
async function handleRefund(charge: Stripe.Charge) {
  if (!charge.metadata.bookingId) return;

  await db.collection('bookings').doc(charge.metadata.bookingId).update({
    status: 'refunded',
    paymentStatus: 'refunded',
    refundedAmount: charge.amount_refunded / 100,
    updatedAt: admin.firestore.FieldValue.serverTimestamp(),
  });
}

// ==========================================
// Helper: Create Stripe Connect Transfer
// ==========================================
async function createHostTransfer(
  hostId: string,
  booking: any,
  paymentIntent: Stripe.PaymentIntent
) {
  try {
    // Get host's Stripe account
    const hostDoc = await db.collection('users').doc(hostId).get();
    const host = hostDoc.data();

    if (!host?.stripeConnectId) {
      functions.logger.warn(`Host ${hostId} missing Stripe Connect ID`);
      return;
    }

    // Calculate transfer amount (after platform fee, cleaning fee, etc.)
    const platformFee = Math.round((booking.totalPrice * 0.1) * 100); // 10% platform fee
    const transferAmount = paymentIntent.amount - platformFee;

    // Create transfer to host
    const transfer = await stripe.transfers.create({
      amount: transferAmount,
      currency: paymentIntent.currency,
      destination: host.stripeConnectId,
      metadata: {
        bookingId: booking.id,
        guestId: booking.guestId,
        listingId: booking.listingId,
      },
    });

    // Update booking with transfer info
    await db.collection('bookings').doc(booking.id).update({
      stripeTransferId: transfer.id,
      hostPayout: transferAmount / 100,
      platformFee: platformFee / 100,
    });

    functions.logger.info(`Transfer created for host ${hostId}: ${transfer.id}`);
  } catch (error: any) {
    functions.logger.error('Error creating host transfer:', error);
  }
}

// ==========================================
// Helper: Send Emails
// ==========================================
async function sendBookingConfirmationEmails(bookingId: string, booking: any) {
  try {
    const guestDoc = await db.collection('users').doc(booking.guestId).get();
    const hostDoc = await db.collection('users').doc(booking.hostId).get();
    const listingDoc = await db.collection('listings').doc(booking.listingId).get();

    const guest = guestDoc.data();
    const host = hostDoc.data();
    const listing = listingDoc.data();

    if (!guest || !host || !listing || !process.env.SENDGRID_API_KEY) return;

    const checkInDate = booking.checkIn?.toDate?.() || new Date(booking.checkIn);
    const checkOutDate = booking.checkOut?.toDate?.() || new Date(booking.checkOut);

    const guestEmail = {
      to: guest.email,
      from: 'bookings@enatbet.app',
      subject: 'âœ… Booking Confirmed - Enatbet',
      html: `
        <h2>Your booking is confirmed!</h2>
        <p>Hi ${guest.displayName || guest.firstName},</p>
        <p>Your booking for <strong>${listing.title}</strong> has been confirmed.</p>
        <h3>Booking Details:</h3>
        <ul>
          <li><strong>Check-in:</strong> ${checkInDate.toLocaleDateString()}</li>
          <li><strong>Check-out:</strong> ${checkOutDate.toLocaleDateString()}</li>
          <li><strong>Guests:</strong> ${booking.guests}</li>
          <li><strong>Total Paid:</strong> ${booking.currency || 'USD'} ${(booking.totalPrice).toFixed(2)}</li>
        </ul>
        <p><strong>Host:</strong> ${host.displayName || host.firstName}</p>
        <p>Open the app to message your host.</p>
      `,
    };

    const hostEmail = {
      to: host.email,
      from: 'bookings@enatbet.app',
      subject: 'ðŸ“… New Booking - Enatbet',
      html: `
        <h2>You have a new booking!</h2>
        <p>Hi ${host.displayName || host.firstName},</p>
        <p>Your listing <strong>${listing.title}</strong> has been booked.</p>
        <h3>Booking Details:</h3>
        <ul>
          <li><strong>Guest:</strong> ${guest.displayName || guest.firstName}</li>
          <li><strong>Check-in:</strong> ${checkInDate.toLocaleDateString()}</li>
          <li><strong>Check-out:</strong> ${checkOutDate.toLocaleDateString()}</li>
          <li><strong>Your Payout:</strong> ${booking.currency || 'USD'} ${(booking.totalPrice * 0.9).toFixed(2)}</li>
        </ul>
      `,
    };

    await sgMail.send([guestEmail, hostEmail]);
    functions.logger.info(`Booking confirmation emails sent for ${bookingId}`);
  } catch (error: any) {
    functions.logger.error('Error sending booking emails:', error);
  }
}

// ==========================================
// Helper: Send Push Notification
// ==========================================
async function sendNotification(userId: string, title: string, body: string) {
  try {
    const userDoc = await db.collection('users').doc(userId).get();
    const user = userDoc.data();

    if (!user?.fcmToken) {
      functions.logger.warn(`User ${userId} missing FCM token`);
      return;
    }

    const message = {
      notification: { title, body },
      tokens: [user.fcmToken],
    };

    const response = await admin.messaging().sendMulticast(message);
    functions.logger.info(`Notification sent to ${userId}: ${response.successCount} success`);
  } catch (error: any) {
    functions.logger.error('Error sending notification:', error);
  }
}

// ==========================================
// Scheduled: Send Booking Reminders
// ==========================================
export const sendBookingReminders = functions.pubsub
  .schedule('every day 09:00')
  .timeZone('America/New_York')
  .onRun(async () => {
    try {
      const tomorrow = new Date();
      tomorrow.setDate(tomorrow.getDate() + 1);
      const tomorrowStart = new Date(tomorrow.setHours(0, 0, 0, 0));
      const tomorrowEnd = new Date(tomorrow.setHours(23, 59, 59, 999));

      const bookingsSnap = await db
        .collection('bookings')
        .where('status', '==', 'confirmed')
        .where('checkIn', '>=', tomorrowStart)
        .where('checkIn', '<=', tomorrowEnd)
        .get();

      for (const doc of bookingsSnap.docs) {
        const booking = doc.data();
        await sendNotification(
          booking.guestId,
          'Reminder: Check-in Tomorrow',
          `Your check-in is tomorrow at ${booking.checkInTime || '3:00 PM'}`
        );
      }

      functions.logger.info(`Sent ${bookingsSnap.size} check-in reminders`);
    } catch (error: any) {
      functions.logger.error('Error sending booking reminders:', error);
    }
  });